
■Java コーディングスタンダード CERT/Oracle 版
https://www.jpcert.or.jp/java-rules/
最終更新: 2019-03-19

はじめに
Androidアプリケーション開発へのルールの適用
00. 入力値検査とデータの無害化 (IDS)
01. 宣言と初期化 (DCL)
02. 式 (EXP)
03. 数値型とその操作 (NUM)
04. オブジェクト指向 (OBJ)
05. メソッド (MET)
06. 例外時の動作 (ERR)
07. 可視性とアトミック性 (VNA)
08. ロック (LCK)
09. スレッド API (THI)
10. スレッドプール (TPS)
11. スレッドの安全性に関する雑則 (TSM)
12. 入出力 (FIO)
13. シリアライズ (SER)
14. プラットフォームのセキュリティ (SEC)
15. 実行環境 (ENV)
49. 雑則 (MSC)
AA. 参考情報
BB. Glossary
XX. お問い合わせ
00入力値検査とデータの無害化 (IDS)
IDS00-J	SQL インジェクションを防ぐ
IDS01-J	文字列は検査するまえに標準化する
IDS02-J	パス名は検証する前に正規化する
IDS03-J	ユーザ入力を無害化せずにログに保存しない
IDS04-J	ZipInputStream からファイルを安全に展開する
IDS05-J	ファイル名やファイルパスにはASCII文字セットの一部の文字のみを使用する
IDS06-J	ユーザからの入力を使って書式を組み立てない
IDS07-J	信頼できない、無害化されていないデータを Runtime.exec() メソッドに渡さない
IDS08-J	信頼できないデータは regex に渡す前に無害化する
IDS09-J	適切なロケールを指定せずに、ロケール依存メソッドをロケール依存データに対して使用しない
IDS10-J	一文字を構成するデータを分割しない
IDS11-J	非文字コードポイントは検証を行う前に削除する
IDS12-J	異なる文字コードへの文字列データの変換はデータが欠損しないように行う
IDS13-J	ファイル入出力やネットワーク入出力の両端で互換性のある文字エンコーディングを使う
Top へ

01宣言と初期化 (DCL)
DCL00-J	クラスの初期化を循環させない
DCL01-J	Java標準ライブラリが使用するパブリック宣言された識別子を再利用しない
DCL02-J	拡張 for 文のループ変数は必ず final 宣言する
Top へ

02式 (EXP)
EXP00-J	メソッドの返り値を無視しない
EXP01-J	null ポインタ参照しない
EXP02-J	配列の中身を比較するには2引数の Arrays.equals() メソッドを使う
EXP03-J	ボクシングされたプリミティブ型の値の比較に等値演算子を使わない
EXP04-J	オートボクシングされた値が想定した型を持つようにする
EXP05-J	ひとつの式の中で同じ変数に2回以上書込みを行わない
EXP06-J	アサーションに副作用を持つ式を使わない
Top へ

03数値型とその操作 (NUM)
NUM00-J	整数オーバーフローを検出あるいは防止する
NUM01-J	同一のデータに対してビット演算と算術演算の両方を行わない
NUM02-J	除算と剰余演算でゼロ除算エラーを起こさない
NUM03-J	符号無しデータのとり得る値をすべて表現できる整数型を使う
NUM04-J	正確な計算が必要なときは浮動小数点数を使わない
NUM05-J	非正規化数を使用しない
NUM06-J	どのプラットフォームでも一貫した浮動小数点数演算を行うために strictfp 修飾子を使う
NUM07-J	NaNとの比較を行わない
NUM08-J	浮動小数点数入力が例外値でないかを検査する
NUM09-J	浮動小数点数型変数をループカウンタとして使用しない
NUM10-J	浮動小数点数リテラルから BigDecimal クラスのオブジェクトを生成しない
NUM11-J	浮動小数点数の文字列表現を比較したり内容を調べたりしない
NUM12-J	数値型の縮小変換時にデータの欠損や誤解釈を引き起こさない
NUM13-J	プリミティブ整数を浮動小数点数に変換する際、精度を低下させない
Top へ

04オブジェクト指向 (OBJ)
OBJ00-J	不変条件を持つクラスやメソッドの拡張は信頼できるサブクラスのみに許す
OBJ01-J	データメンバはprivate宣言し、それにアクセスするためのラッパーメソッドを提供する
OBJ02-J	スーパークラスに変更を加える場合、サブクラスの依存性を保つ
OBJ03-J	ジェネリックな未加工型とジェネリックでない未加工型を新規コードに混在させない
OBJ04-J	信頼できないコードにインスタンスを安全に渡すため、可変クラスにはコピー機能を実装する
OBJ05-J	privateかつ可変なクラスメンバへの参照を返す前にそのディフェンシブコピーを作成する
OBJ06-J	可変入力や可変な内部コンポーネントはディフェンシブコピーを作成する
OBJ07-J	センシティブなクラスはコピーさせない
OBJ08-J	入れ子クラスから外側のクラスのprivateメンバを公開しない
OBJ09-J	クラス名を比較するのではなくクラスを比較する
OBJ10-J	public static 変数を final 宣言せずに使わない
OBJ11-J	コンストラクタが例外をスローする場合には細心の注意を払う
Top へ

05メソッド (MET)
MET00-J	メソッドの引数を検証する
MET01-J	メソッドの引数の検証にassertを使わない
MET02-J	非推奨(deprecated)あるいは廃止された(obsolete)クラスやメソッドを使用しない
MET03-J	セキュリティチェックを行うメソッドは private もしくは final 宣言する
MET04-J	メソッドをオーバーライドあるいは隠蔽するときにアクセス範囲を広げない
MET05-J	コンストラクタにおいてオーバーライド可能なメソッドを呼び出さない
MET06-J	clone() からオーバーライド可能なメソッドを呼び出さない
MET07-J	スーパークラスやスーパーインタフェースで宣言されているメソッドを隠蔽するようなクラスメソッドを宣言しない
MET08-J	equals() メソッドをオーバーライドする時は等価性に関する契約を守る
MET09-J	equals() メソッドを実装するクラスでは hashCode() メソッドも実装する
MET10-J	compareTo() メソッドを実装する場合メソッドの一般契約に従う
MET11-J	比較演算に用いるキーは不変にする
MET12-J	ファイナライザは使わない
Top へ

06例外時の動作 (ERR)
ERR00-J	チェック例外を抑制あるいは無視しない
ERR01-J	センシティブな情報を例外によって外部に漏えいしない
ERR02-J	ログ保存中の例外発生を防ぐ
ERR03-J	メソッドが処理に失敗した場合はオブジェクトの状態を元に戻す
ERR04-J	finally ブロックの処理を途中で終了しない
ERR05-J	チェック例外を finally ブロックの外に伝播させない
ERR06-J	宣言されていないチェック例外をスローしない
ERR07-J	RuntimeException, Exception, Throwable をスローしない
ERR08-J	NullPointerException およびその親クラスの例外をキャッチしない
ERR09-J	信頼できないコードにJVMを終了させない
Top へ

07可視性とアトミック性 (VNA)
VNA00-J	共有プリミティブ型変数の可視性を確保する
VNA01-J	不変オブジェクトへの共有参照の可視性を確保する
VNA02-J	共有変数への複合操作のアトミック性を確保する
VNA03-J	アトミックなメソッドをまとめた呼び出しがアトミックであると仮定しない
VNA04-J	メソッドチェーン呼出しのアトミック性を確保する
VNA05-J	64ビット値の読み書きはアトミックに行う
Top へ

08ロック (LCK)
LCK00-J	信頼できないコードから使用されるクラスを同期するにはprivate finalロックオブジェクトを使用する
LCK01-J	再利用されるオブジェクトを使って同期しない
LCK02-J	getClass() メソッドが返す Class オブジェクトを同期に使用しない
LCK03-J	高水準な並行処理オブジェクトの固有ロックを使って同期を行わない
LCK04-J	基になるコレクションにアクセス可能な場合にはコレクションビューを使って同期しない
LCK05-J	信頼できないコードによって変更されうる static フィールドへのアクセスは同期する
LCK06-J	共有staticデータの保護にインスタンスロックを使用しない
LCK07-J	デッドロックを回避するためにロックは同一順序で要求および解放する
LCK08-J	例外発生時には保持しているロックを解放する
LCK09-J	途中で待機状態になる可能性のある操作をロックを保持したまま実行しない
LCK10-J	ダブルチェックロック手法を誤用しない
LCK11-J	一貫したロック方式を定めていないクラスを使用する場合、クライアントサイドロックを行わない
Top へ

09スレッド API (THI)
THI00-J	Thread.run() メソッドを直接呼び出さない
THI01-J	ThreadGroup クラスのメソッドを使用しない
THI02-J	1つではなくすべての待ち状態スレッドへ通知を行う
THI03-J	wait() および await() メソッドは常にループ内部で呼び出す
THI04-J	ブロックしているスレッドやタスクが確実に終了できるようにする
THI05-J	スレッドの強制終了にThread.stop()メソッドを使用しない
Top へ

10スレッドプール (TPS)
TPS00-J	スレッドプールを使用しトラフィックの大量発生による急激なサービス低下を防ぐ
TPS01-J	スレッド数に上限のあるスレッドプールで相互に依存するタスクを実行しない
TPS02-J	スレッドプールにサブミットするタスクは割込み可能にする
TPS03-J	スレッドプールで実行されるタスクを通知なしに異常終了させない
TPS04-J	スレッドプールの使用時にはThreadLocal変数の再初期化を確実に行う
Top へ

11スレッドの安全性に関する雑則 (TSM)
TSM00-J	スレッドセーフなメソッドを、スレッドセーフでないメソッドでオーバーライドしない
TSM01-J	オブジェクトの構築時にthis参照を逸出させない
TSM02-J	クラスの初期化中にバックグラウンドスレッドを使用しない
TSM03-J	初期化が完了していないオブジェクトを公開しない
Top へ

12入出力 (FIO)
FIO00-J	共有ディレクトリにあるファイルを操作しない
FIO01-J	適切なパーミッションを設定してファイルを作成する
FIO02-J	ファイル関連エラーを検知し、処理する
FIO03-J	一時ファイルはプログラムの終了前に削除する
FIO04-J	不要になったリソースは解放する
FIO05-J	wrap() や duplicate() メソッドで作成したバッファを信頼できないコードにアクセスさせない
FIO06-J	1つの InputStream に対して複数のバッファ付きラッパーを作成しない
FIO07-J	外部プロセスに IO バッファをブロックさせない
FIO08-J	文字やバイトを読み取るメソッドの返り値はintで受ける
FIO09-J	0から255の範囲に収まらない整数値を出力するときには write() メソッドを信用しない
FIO10-J	read() を使って配列にデータを読み込むときには配列への読み込みが意図した通りに行われたことを確認する
FIO11-J	バイナリデータを文字データとして読み込もうとしない
FIO12-J	リトルエンディアン形式のデータを読み書きするメソッドを用意する
FIO13-J	センシティブな情報を信頼境界の外に記録しない
FIO14-J	プログラムの終了時には適切なクリーンアップを行う
Top へ

13シリアライズ (SER)
SER00-J	開発中のクラスにおいてシリアライズの互換性を維持する
SER01-J	シリアライズに関連するメソッドは正しいシグネチャで実装する
SER02-J	センシティブなオブジェクトは信頼境界を越えて送信する前に署名し暗号化する
SER03-J	暗号化されていないセンシティブなデータをシリアライズしない
SER04-J	シリアライズと復元においてセキュリティマネージャによるチェックをバイパスさせない
SER05-J	内部クラスのインスタンスをシリアライズしない
SER06-J	復元時には private 宣言された可変コンポーネントはディフェンシブコピーする
SER07-J	実装上必要となる不変条件がある場合にはデフォルトのシリアライズ形式を使わない
SER08-J	特権を持ったコンテキストでは必要最小限の権限でオブジェクトを復元する
SER09-J	オーバーライド可能なメソッドを readObject() メソッドから呼び出さない
SER10-J	シリアライズの過程でメモリリークやリソースリークをしない
SER11-J	Externalizable を実装したオブジェクトの上書きを防ぐ
SER12-J	信頼できないクラスの復元はしない
SER13-J	デシリアライズするデータは悪質なものという前提で処理する
Top へ

14プラットフォームのセキュリティ (SEC)
SEC00-J	センシティブな情報を特権ブロックから信頼境界を越えて漏えいさせない
SEC01-J	汚染された変数を特権ブロックの中で使わない
SEC02-J	信頼できない入力値に基づいてセキュリティチェックを行わない
SEC03-J	信頼できないコードに任意のクラスのロードを許可した後で信頼するクラスをロードしない
SEC04-J	センシティブな処理はセキュリティマネージャによるチェックで保護する
SEC05-J	リフレクションを使ってクラス、メソッド、フィールドのアクセス範囲を広げない
SEC06-J	URLClassLoader と java.util.jar が提供するデフォルトの署名自動検証機能に頼らない
SEC07-J	クラスローダを独自に実装する場合スーパークラスの getPermissions() メソッドを呼び出す
SEC08-J	ネイティブメソッドにはラッパーメソッドを定義する
Top へ

15実行環境 (ENV)
ENV00-J	特権の必要ない動作のみを行うコードを署名しない
ENV01-J	セキュリティ上重要なコードは署名付きの1つの JAR にまとめてシールする
ENV02-J	環境変数の値を信頼しない
ENV03-J	危険な組み合わせのパーミッションを割り当てない
ENV04-J	バイトコード検証機能を無効にしない
ENV05-J	遠隔から監視できる状態のままアプリケーションを実運用しない
Top へ

49雑則 (MSC)
MSC00-J	セキュアなデータ交換には Socket クラスではなく SSLSocket クラスを使用する
MSC01-J	空の無限ループを使用しない
MSC02-J	高品質の乱数を生成する
MSC03-J	センシティブな情報をハードコードしない
MSC04-J	メモリリークしない
MSC05-J	ヒープメモリを使い果たさない
MSC06-J	繰り返し処理中に基となるコレクションを変更しない
MSC07-J	シングルトンオブジェクトのインスタンスを複数作らない
Top へ

AA参考情報
References (CERT Oracle Secure Coding Standard for Java のページにとびます)
『Java セキュアコーディング 並行処理編』
Top へ


