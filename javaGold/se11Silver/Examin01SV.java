/**
 * @title javaGold / se11Silver / Examin01SV.java
 * @reference 志賀澄人 『徹底攻略 Java SE11 Silver 問題集[1ZO-815]』 インプレス, 2019
 * @content  Silver総合問題１
 * @author shika
 * @date 2021-05-18
 */
/* Appendix 2021-05-18
 * @costTime 09:28 - 11:25 ( 116 分)
 * @correctRate 正答率 85.00 ％ ( 〇68問 / 全80問 )
 */
package javaGold.se11Silver;

import javaGold.PracticeEditor;

public class Examin01SV {

    public static void main(String[] args) {
        new PracticeEditor();
    }//main()

}//class
/*
//====== 2021-05-18 ======
 Silver総合問題１
Ｘ （1） C -> D
   => java11からソースファイルモードで実行することができるようになったが、
   *  この方法で実行すると .classクラスファイルを生成せず、
   *  JVM内にクラスファイルにあたるものを再現し実行する。
   *
   *  題意の「クラスファイルを生成」から、javacでコンパイルが必要。
   *  クラスAをコンパイルすると、import Bしているので、クラスBも自動的に生成される。
   *
〇 （2） A
〇 （3） C
〇 （4） E
    => ラムダ内から、ラムダを囲むブロックのローカル変数を参照する際は
    *  final, 実質finalでないとコンパイルエラー。
    *  ラムダ後に変更をしても不可。
    *
〇 （5） C
    => int num = num;はローカル変数が初期化されておらずコンパイルエラー。

Ｘ （6） A, C -> A, D
   => ◆相互依存のモジュール
       * 相互に requiresするモジュールはコンパイラが永久ループしてしまうため、
   *  コンパイルエラーになる。

Ｘ （7） B -> C
       => switch文の defaultは どこに記述してもよい。
       *  評価は caseから、あてはまるものがないと default
       *  break;がないのでフォールスルーが起こる。

〇 （8） E
Ｘ （9） A, B -> B, E
       => ◆モジュールの依存関係を調べるコマンド
       *  jdeps --list-deps クラスの依存関係を調べる
       *  java --show-module-resolution モジュールの依存関係
       *  jmod モジュールを作成するコマンド

〇 （10） B
       => クラスC は クラスB を継承しているため、Z()は必ず実装しなければならない。
       *  クラスC は インターフェイスAも実装しているため、 X()も実装する必要があるが、
       *  クラスCのインスタンスには、クラスBのインスタンス内容も含まれるため、
       *  クラスCは、クラスBで定義された X()も持つ

〇 （11） A
〇 （12） D
〇 （13） D
      => switch()の条件式には、プリミティブ型、String, Enumが可能。
      *  switchの分岐には hashCode()が使われる
      *  switch(null) -> null.hashCode()となり、NullPointerException

〇 （14） B
〇 （15） B
    => javac -d <ディレクトリ名>: 生成する .classクラスファイルの置き場所を指定。
    *    必要なディレクトリ構造がない場合は、ディレクトリ構造も作ってくれる。
    *  java -cp <クラスファイルの置き場所>

〇 （16） D
〇 （17） A, E
〇 （18） D
〇 （19） D
      => A a = new B();で
      *  a.bye()は Aクラスに bye()の定義がなくコンパイルエラー。

〇 （20） D
〇 （21） A, E
〇 （22） A
〇 （23） A, C, E
〇 （24） D
     => ◆ダイアモンド継承  / 菱形継承
     * defaultのメソッドが重複して、
     * メソッド呼出の際どちらを選択していいか分からなくなるとき
     * コンパイルエラー。
     *
     * B.super.sample();とインターフェイス名を記述するとＯＫ。
     * また、階層が異なる場合は、より近いものが選ばれるので問題にならない。

〇 （25） C
〇 （26） D
     => D d = new C()はキャストが必要な代入。
     *  設問はListのジェネリックでこれをしているが、
     *  ジェネリックに共変の性質はなく、<? extends A>などの記述がないと、
     *  すべてコンパイルエラーになるのでは？

〇 （27） B?
Ｘ （28） A, B, E -> A, B, F
    => interfaceにも abstractを付記して宣言可。
    *  付けなくても public abstractを暗黙付記。

〇 （29） A, D
      => ◆モジュールの特徴
      *  〇A: JREの必要なモジュールだけ jlinkコマンドでリンクさせて、
      *       アプリケーションを実行できる。
      *  〇D: パッケージ単位で情報隠蔽できるようになり、
      *       セキュリティとメンテナンス性が向上
      *  Ｘ C: 情報隠蔽はできる限り、実装を隠し、
      *       インターフェイスのような抽象的なものを公開。
      *       実装を公開するのは推奨されない。
      *  Ｘ E:「堅牢性」エラーになるような操作や事態が発生しても、
      *      ユーザに影響を与えない能力のこと。
      *      モジュールとは関係がなく、アプリケーションの非機能要件や設計の課題。

〇 （30） C
〇 （31） C
〇 （32） A
Ｘ （33） B -> E
      => List.of()で不変リストを生成。
      *  list.clear()で要素を削除いているので、
      *  UnsupportedOperationException

〇 （34） A
〇 （35） A
     => privateなメンバーに @Overrideを付けるとコンパイルエラー。
     *  クラス内からの呼出のみ許される。
     *  A a = new B();で print()が Bにも定義されていても、
     *  Overrideできないので、Aクラスから print()を呼ぶと A.print()が呼ばれる。
     *
     *  アクセス修飾子を private以外にすると Overrideが成立し、
     *  Aクラスで呼んだ print()は Overrideの B.print()を呼び
     *  「B」「B」を表示。

〇 （36） A
〇 （37） C, E
       => void内の retrun; は制御を戻す returnで戻り値を返さないのでＯＫ。

〇 （38） D
〇 （39） B
〇 （40） C
〇 （41） C?
       => ◆共変戻り値
       *  Overrideするメソッドは同じ型の戻り値か、そのサブクラスの戻り値は
       *  認められていること
       *    ↓
       *  インターフェイスを多重実装した場合、
       *  同名メソッドで戻り値が違うと、上記「共変戻り値」で許可されうる型を決められない。
       *  コンパイルエラー。
〇 （42） C
〇 （43） D
Ｘ （44） D -> E
       => 継承関係にある場合、コンストラクタには super()が自動付与。
       *  superに引数なしのコンストラクタがなく、
       *  デフォルトで出現しない場合(= 引数ありのコンストラクタがすでにある場合)
       *  super()の呼出先がなくコンパイルエラー。

〇 （45） B
〇 （46） A
〇 （47） A
〇 （48） A
〇 （49） A
〇 （50） D
〇 （51） A, C,
〇 （52） C
Ｘ （53） B -> A
      => 算術演算より、キャストのほうが優先
      => B: Math(250.0) -> 250
      *     250 / 100 int同士なので -> 2

Ｘ （54） C -> D
   => C: Sub.test(int)は、引数が異なるオーバロード。
   *  なので Override規則の publicにしなくても可。
   *  正常にコンパイル・実行できる。

〇 （55） A, B, D, F
〇 （56） B
〇 （57） C
〇 （58） A
〇 （59） A
Ｘ （60） E -> C
       => Long + Integerは アンボクシングで long + int
       *  型範囲の大きいほうに合わされて long
       *
       *  (String) longは互換性がなくコンパイルエラー。
       *
       *  ClassCastExceptionは配列の要素型など、実行時に決まる型
       *  文法上コンパイル時に分かる型の違いはコンパイルエラー。

Ｘ （61） B -> A
      => new String("Java")はインスタンス
      *  String s2 = "Java";はリテラル。コンパイル時に定数として扱われる
      *  String.intern()メモリ上にある Stringオブジェクトを参照。
      *  ２つ目の Stringオブジェクトへの参照を取り出して代入

〇 （62） A
〇 （63） C
〇 （64） C
〇 （65） A
〇 （66） D
〇 （67） A
〇 （68） A, E
〇 （69） D
    => java.lang.OutOfMemoryError
    *  Exception, RuntimeExceptionでは捕捉できず、実行中に例外throw

〇 （70） C
〇 （71） D
〇 （72） B
〇 （73） B
〇 （74） D
    => null.concat()のタイミングで NullPointerException。
    *  null + "null"だと、nullnull

〇 （75） B
〇 （76） B
Ｘ （77） D -> E
    => Super super = new Sub();
    *  Sub sub = new Sub();
    *  sub = super;コンパイルエラー。
    *  キャストを記述すればＯＫ。
    *
    *  ClassCastExceptionは配列の要素型など、実行中に型が決まるもの
    *  文法上の型が異なる場合はコンパイルエラー。
    *  と言ってもその区別が難しいんだな。

〇 （78） A, D
〇 （79） A, B
〇 （80） A

開始時刻 09:28
終了時刻 11:25
所要時間 116 分
正答率 85.00 ％ ( 〇68問 / 全80問 )
*/

