/**
 * @title javaGoF / chap20Flyweight / hugeNumber / MainHugeNumber.java
 * @reference 結城 浩 『Java言語で学ぶデザインパターン入門 [増補改訂版]』 SB Creative, 2004
 * @content 第20章 Flyweight / インスタンスを共有する。
 *          huge:[英] 巨大な -> hugeStr: 横16 × 縦 8の ascii文字
 *
 *          テキスト仕様は txtファイルに元データを書き、
 *          それを FileReaderで読み込ませて、
 *          必要に応じて HugeNumberクラスを poolMapで保存する。
 *
 * @content 自作 version
 *          NumberDataに binaryデータの16進数表記で表示のデータ int[]を用意。
 *          その int[]を 集合した List<int[]>を作る。
 *          必要に応じて、各 int[]から StringBuilderで hugeStrを作成。
 *          テキスト仕様と大きく違うクラス構成になってしまった。
 *          => 以下【考察】へ
 *
 * @class MainHugeNumber / ◆main()
 * @class NumberData
 * @class HugeNumber
 * @class HugeNumberFactory
 *
 * @author shika
 * @date 2021-06-26
 */
package javaGoF.chap20Flyweight.hugeNumber;

import java.util.List;
import java.util.stream.Collectors;

public class MainHugeNumber {

    public static void main(String[] args) {
        var runtime = Runtime.getRuntime();
        runtime.gc();
        var factory = HugeNumberFactory.getInstance();

        final String target = "1212123";
        List<String> targetList = target.chars()     //IntStream 49, 50, 51, 49 ..
            .mapToObj(i -> String.valueOf((char) i)) //Stream<String>  1, 2, 3, 1 ...
            .map(Integer::valueOf)        //String -> Integer
            .map(factory::getNumberData)  //int index -> String hugeStr
            //.map(i -> new HugeNumber(i).getHugeStr())
            .collect(Collectors.toList());//List<String>に代入

        targetList.forEach(System.out::println);
        System.out.println(
            "poolMap.size(): " + factory.getPoolMap().size());

        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("usedMemory: " + usedMemory);
    }//main()

}//class

/*

......##........
..######........
......##........
......##........
......##........
......##........
..##########....

....######......
..##......##....
..........##....
......####......
....##..........
..##............
..##########....

......##........
..######........
......##........
......##........
......##........
......##........
..##########....

....######......
..##......##....
..........##....
......####......
....##..........
..##............
..##########....

......##........
..######........
......##........
......##........
......##........
......##........
..##########....

....######......
..##......##....
..........##....
......####......
....##..........
..##............
..##########....

....######......
..##......##....
..........##....
......####......
..........##....
..##......##....
....######......

//---- 練習問題 20-2 ----
//map(factory::getNumberData)
poolMap.size(): 3
usedMemory: 1044832

//map(i -> new HugeNumber(i).getHugeStr())
poolMap.size(): 0
usedMemory: 1090984

【考察】
＊練習問題 20-2 メモリ消費について
たいして変化ない。あっ１回分でこれだから、差が 約 50000
1000回やったら、だいぶ違いそうだが、やはり List<int[]>が重いんかな。

テキスト仕様はインスタンスを poolしていたが、
new HugeNumber()は１回で、
データから生成したStringの poolのみで十分なのではなかろうか

自作versionでは、各hexAryのデータを全て new int[]しているので、
List<int[]>生成時に、たくさんのメモリを確保していることになる。
テキスト仕様なら、必要なファイルの読み込みだけなので、その分のメモリだけで済む。

＊showNumber(int index)について
引数の intは そのままList<int[]>の検索に利用できるのだが、
元データ "1212123"から int indexにする場合の型変換が煩雑で(Main)
テキスト仕様のように getBigChar(char charname)と
引数 char型にしておいたほうが、 getBigChar(str.charAt(i))で呼び出せて便利。

それと NumberDataを int[]に 16進数要素を入れて、
利用時に２進数に変換。 0011001111の「0」「1」をそれぞれ文字列に変換して表示。

NumberDataの hexAryを見ると、「0」「3」「c」「f」の４種だけなので
String[]に "03f0"と入れて、"3" -> "..##" / "f" -> "####"などと変換してもいい。

intの数値の場合、先頭桁の「0」は消されてしまうので、
最大桁数との差を取って「00」を補う必要がある。
DecimalFormatも使ってみたが、表示時には 0が入っても、
メモリ内の認識は先頭の「0」が除かれるので、toString()しても「0」は入らない。
String[]の変換方式なら、「0」を補う必要はなくなる。
*/

